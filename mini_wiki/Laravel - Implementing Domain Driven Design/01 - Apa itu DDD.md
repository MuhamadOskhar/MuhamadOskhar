DDD sendiri dibangun menggunakan berbagai peraktik terbaik dan pola desain yang dapat diandalkan, dan memiliki akar yang berasal dari extreme programming (XP) dan pengembangan agile. Saya akan memperkenalkan kepada anda beberapa aspek fundamental yang lebih mendasar dari DDD, termasuk buruknya perangkat lunak dibuat tanpa best practicies dan pola SOLID karena ketidaktahuan pengembang atau upaya pengembang yang buruk.

Sederhananya DDD adalah serangkaian konsep, proses, dan teknik praktis dan berguna yang membantu dalam pemodelan sistem perangkat lunak kompleks secara sistematis dan terstruktur dengan fokus pada aspek inti dari aturan bisnis yang mendasarinya untuk menghasilkan model domain yang benar benar menjelaskan dan mewakili bisnis tersebut dalam hal perangkat lunak, dan kemudian membiarkan pengetahuan dan wawasan dari diskusi berulang dan pertemuan kelompok dengan para ahli domain yang bersangkutan memandu pengembangan dan pembangunan perangkat lunak yang pada akhirnya dibangun untuk melayani pelanggan atau pengguna depan bisnis tersebut. DDD pada dasarnya muncul dari kesenjangan industri perangkat lunak yang berkaitan dengan menjawab pertanyaan tentang bagaimana merancang dan mengembangkan perangkat lunak yang baik dan paling sesuai dengan bisnis tersebut. Tidak ada panduan ajaib yang memberikan standar atau pendekatan dasar apapun untuk membangun aplikasi yang berfokus pada domain aplikasi (domain centric), dan juga tidak ada pendekatan yang dipublikasikan untuk mempelajari seluk beluk dari proses inti bisnis yang cukup untuk membangun perangkat lunak yang mewakilinya.

Para progammer telah memiliki pola dalam kota alat kode kami selama bertahun tahun, meskipun mereka tidak pernah didokumentasikan seperti itu hingga tahun 1994 ketika gang of four menerbitkan buku desain pola yang sangat terkenal "Design Patterns: Element Of Reusable Object-Oriented Software". Design Patterns berfungsi sebagai seperangkat solusi praktis dan dapat diulang yang penting untuk masalah umum yang mungkin anda hadapi saat membangun program komputer. Mereka adalah cara yang terpikirkan dengan baik dan diuji dengan baik untuk mengatasi aspek aspek umum dari cakupan masalah yang mungkin anda temui dalam hampir semua program, dalam berbagai bahasa pemrorgamman. Salah satu pola tersebut, pola strategis terkenal, berguna ketika anda memberikan perilaku tambahan kepada objek pada saat runtime dengan mengemas perubahan ke dalam keluarga perilaku. Yang lain adalah pola adapter, yang digunakan untuk mengintegrasikan dua antarmuka yang berbeda (seperti yang berjalan pada sistem yang berbeda atau diprogram dalam bahasa pemrogramman yang benar benar berbeda). Jika anda memerlukan perilaku dinamis pada objek anda yang dapat ditambahkan atau dihapus saat runtime dan mengikuti suite yang mirip yang memungkinkan perhitungan agresi ditempatkan pada kelompok objek tersebut, anda bisa menggunakan decorator pattern.

Apa yang kita butuhkan adalah hal yang sama untuk mengembangkan solusi dalam bentuk kode untuk sejumlah masalah bisnis yang terus berkembang dan luas yang muncul sebagai tanggapan terhadap peningkatan permintaan pengembangan perangkat lunak. Dengan kata lain, kita membutuhkan suatu pendekatan untuk mengembangkan lapisan domain dari sebuah aplikasi sehingga kita dapat menyatakan model domain (bisnis) apa pun dalam bentuk perangkat lunak. Sifat masalah bisnis adalah cenderung sangat spesifik, dan solusi mereka merupakan hasil dari bertahun-tahun merancang, mengembangkan, menguji, dan menyempurnakan proses bisnis yang unik untuk setiap bisnis atau industri. Oleh karena itu, sulit untuk menetapkan standar atau praktik terbaik untuk memfasilitasi pengembangan aspek paling kritis dari proyek perangkat lunak mana pun: lapisan domain. Sebaliknya, ada banyak referensi, toolkit, dan kerangka kerja yang membantu merancang lapisan lain (yang mungkin memang berkomunikasi dan mengetahui tentang lapisan domain), tetapi mereka tidak mengkapsulkannya. Sebaliknya, mereka mengelilinginya. Lapisan infrastruktur pada dasarnya adalah perantara antara lapisan aplikasi dan model domain. Ini memfasilitasi semua bagian yang beroperasi, memanage, dan mengelola objek domain secara langsung.

Apa yang kita butuhkan adalah taktik tentang bagaimana mencari sumber kebenaran di perusahaan tempat kita bekerja untuk memodelkannya dengan benar dalam perangkat lunak, dan alat untuk membantu kami mengimplementasikan model tersebut dengan cara yang berorientasi pada domain. Informasi bisnis tidak selalu langsung atau mudah untuk diperoleh, terutama dalam konteks proses bisnis yang kompleks yang tersebar di beberapa komponen (setidaknya kita berharap mereka terpisah dalam suatu struktur komponen, tetapi ini tidak selalu menjadi kenyataan). Dalam situasi di mana kode dalam aplikasi sangat "dicampur aduk" atau diubah oleh sejumlah pengembang selama bertahun-tahun sehingga perilakunya melenceng dari yang dimaksud atau dirancang, mengimplementasikan pendekatan yang berorientasi pada domain menjadi lebih sulit. Namun, masih mungkin untuk menghindari menulis ulang seluruh aplikasi (yang hampir selalu merupakan ide yang buruk). Kami akan menjelajahi cara melakukannya nanti dalam buku ini, tetapi jawaban singkatnya adalah dengan menggunakan lapisan anti-korupsi untuk memisahkan bagian-bagian aplikasi, kemudian terus menggantikan kode lama dengan bagian yang lebih kecil hingga lapisan tersebut menyerap kode lama, sehingga tidak ada kode lama yang tersisa sama sekali.
### Arsitektur
Arsitektur suatu sistem memperindah seluruh struktur model domain sistem, termasuk objek domain, modul, konteks terbatas, dan berbagai interaksi di antara mereka. Arsitektur merupakan salah satu hal paling penting dalam suatu aplikasi, karena merupakan dasar utama dalam perangkat lunak dan bertindak sebagai "tiang dukungan" bagi bagian lain dari aplikasi untuk dibangun.

Apa yang sering terjadi dalam dunia nyata adalah bahwa proses bisnis dan model-model ini dibangun tanpa praktik terbaik atau struktur yang tepat dan digunakan dalam produksi karena "berfungsi". Jangan salah paham, para pengembang bekerja dengan apa yang ada dan biasanya dapat "merangkai" sesuatu yang memang "berfungsi". Namun, ketika kita mengabaikan untuk melakukan refaktor terhadap kode ini setelah melakukan penyempurnaan pada proses itu sendiri, atau gagal menyempurnakan definisi yang tidak jelas atau samar yang mungkin telah kita klarifikasi, atau gagal mencerminkan wawasan yang diperoleh ke dalam model bisnis dan bagaimana wawasan tersebut memengaruhi operasi bisnis dan perangkat lunaknya, kita kemungkinan besar menuju ke arah "big ball of mud" (atau yang saya sebut sebagai "big ball of sh...potato pottåto").

Dalam konteks ini, "big ball of mud" merujuk pada kondisi di mana kode menjadi sulit dimengerti, sulit dipelihara, dan tidak mengikuti praktik-praktik terbaik atau struktur yang baik. Pernyataan tersebut menyoroti pentingnya melakukan pemeliharaan, refaktorisasi, dan pembaruan terhadap arsitektur perangkat lunak agar tetap relevan dan efisien seiring waktu.

> "sebuah sistem yang dibangun secara sembarangan, merambat, berantakan, seperti hutan kawat duct tape, dan benang rafia kode spageti. Sistem-sistem ini menunjukkan tanda-tanda pertumbuhan yang tidak teratur, dan perbaikan berulang yang bersifat ekspedisi..." — Brian Foote

Biasa, bola lumpur ini dibangun sebagai arsitektur monolitik, yang kurang memiliki pemisahan konsep yang lengkap pada "tingkat platform" (tingkat fisik). Arsitektur monolitik bersifat mandiri dan mencakup dalam dirinya semua aspek aplikasi (infrastruktur, basis data, tingkat aplikasi, dan masalah presentasi). Kebalikan dari aplikasi monolitik adalah mikroservis. Mikroservis adalah aplikasi kecil yang terdistribusi di berbagai komponen yang bersama-sama membentuk sistem lengkap yang dapat digunakan. Pengaturan yang terlibat dalam arsitektur mikroservis jauh lebih dramatis daripada hanya menggunakan nama direktori (yang sebenarnya hanya memisahkan struktur-struktur berbagai kelompok yang terkait secara fisik). Komponen-komponen itu sendiri seringkali ada di platform terpisah, biasanya di mesin-mesin terpisah di cloud, dan menerapkan berbagai strategi untuk memfasilitasi penggunaannya dan memungkinkan komunikasi di antara mereka dan klien.

Dalam konteks ini, "monolitik" mengacu pada aplikasi yang dibangun sebagai satu entitas besar yang mencakup semua aspek dari infrastruktur hingga tampilan pengguna, tanpa pemisahan yang jelas antara bagian-bagian tersebut. Sebaliknya, "mikroservis" mengacu pada pendekatan di mana aplikasi dibangun sebagai serangkaian layanan kecil dan terpisah yang bekerja bersama untuk membentuk keseluruhan sistem. Mikroservis umumnya memiliki keuntungan dalam hal skalabilitas, pemeliharaan, dan fleksibilitas, tetapi juga memerlukan pengaturan yang lebih kompleks.
### Enter Laravel
Salah satu fitur inti dari DDD adalah bahwa ini pendekatan agnostik dalam merancang arsitektur sistem. Ini berarti tidak membuat asumsi terhadap framework yang Anda gunakan, database yang Anda pilih, atau bahkan apakah Anda menggunakan persistensi data sama sekali (jika Anda seorang pengembang web, tentu saja, Anda kemungkinan besar melakukannya). Ini dimaksudkan lebih sebagai pendekatan umum untuk merancang sistem enterprise yang dapat diskalakan. Jadi, mengapa saya menyarankan tidak hanya konsep framework, tetapi jenis khusus dari satu (yaitu, Laravel) yang digabungkan dengan konsep dan strategi yang ditawarkan dalam DDD?

Pertanyaan ini dapat dijawab dengan ungkapan lama yang semakin benar setiap hari: kebutuhan adalah ibu dari penemuan. Saya melihat kebutuhan dunia nyata untuk seperangkat pedoman tentang bagaimana mengembangkan sistem web kompleks dan beberapa strategi tentang cara mengimplementasikan aplikasi berbasis domain dalam skenario dunia nyata, tanpa menciptakan kembali roda dan sambil menggunakan beberapa alat populer dalam perdagangan pengembangan web seperti Laravel dan Eloquent—memungkinkan mereka melakukan yang terbaik sehingga kita dapat fokus pada pemodelan bisnis itu sendiri dan membangun lapisan domain yang kaya, yang mencerminkan kebutuhan dan persyaratan bisnis yang dibuat untuk dikelola. Semua ini akan dicapai dengan alat dan konsep yang disertakan dengan DDD, namun disesuaikan untuk digunakan dalam proyek pengembangan web, bersamaan dengan implementasi konsep-konsep tersebut dalam aplikasi Laravel.
Baru-baru ini, kedua konsep tersebut (domain-driven design dan framework) mendekat cukup untuk benar-benar menghasilkan cukup daya tarik yang akan menunjukkan bahwa akan berguna untuk memiliki pendekatan berbasis domain untuk mengembangkan aplikasi berbasis web dan internet. Saya menyadari, akhirnya, bahwa Laravel dapat digunakan sebagai medium untuk membangun DDD.

Namun, karena cara DDD dibuat dan juga karena struktur dasar aplikasi web, ini tidak sepenuhnya sesuai dengan ide menggunakan framework apa pun. Kita akan membahas banyak contoh di mana area yang kabur terletak dalam hubungannya dengan pedoman DDD. Kita hampir memerlukan semacam implementasi DDD khusus untuk dapat bekerja dengannya pada tingkat yang kita butuhkan untuk membangun aplikasi web menggunakan itu sebagai tulang punggung desain domain. Jika kita mempertimbangkan bahwa bekerja dalam konteks pengembangan web berkaitan dengan batasan kontekstual dalam sistem yang perlu beroperasi secara langsung dan utama melalui jaringan. Jika kita melihat kategori pengetahuan yang terkandung dalam pilar Strategi Teknis DDD, sangat jelas bahwa mereka bisa ada bersama aplikasi Laravel (misalnya, repositories, DTOs, factories, jobs, dll.)... Kita sebenarnya dapat melihat bahwa sebagian besar pendekatan yang disarankan oleh DDD cukup cocok dengan komponen dan cara kerja internal Laravel. Dalam hal ini, DDD sangat cocok untuk membentuk sistem web atau aplikasi internet.

Ide untuk mengimplementasikan desain berbasis domain menggunakan framework Laravel tampaknya sangat memungkinkan bagi saya. Jika saya bisa melengkungkan beberapa aturan dalam strategi dan pedoman, saya bisa membuat kedua teknologi ini bekerja dengan baik bersama. Karena itu, saya akan langsung mengatakan bahwa ini bukan implementasi sejati dari DDD dan semua aspek, pola, pendekatan, dan pedoman yang berbeda. DDD membutuhkan banyak pekerjaan di awal, tetapi memberikan hasil yang besar ketika semuanya sudah teratur. Meskipun demikian, saya menyadari bahwa ini tidak selalu diinginkan, terutama jika Anda adalah startup atau bekerja untuk startup. Biaya bisa membangun startup atau menghancurkan startup, dan tidak selalu mungkin untuk mengalokasikan begitu banyak sumber daya, waktu, dan uang untuk menempatkan semua alat, prosedur, dan struktur arsitektural yang akan menjadi hasil dari analisis eksploratif yang mendalam tidak hanya terhadap kode (jika Anda sudah bekerja dalam basis kode) tetapi juga terhadap fungsi inti bisnis.

Jadi, Anda harus sangat hati-hati dengan keputusan Anda untuk membangun aplikasi menggunakan pedoman DDD: sebagian besar domain tidak cukup kompleks untuk memerlukan tingkat kompleksitas yang DDD berusaha atur secara ringkas. Di sisi lain, Laravel menawarkan pendekatan yang lebih terjangkau untuk membuat implementasi dari suatu domain berdasarkan model bisnis. Minat saya dalam menulis buku ini terletak pada penggunaan kedua teknologi ini bersama-sama dalam konteks proyek dunia nyata. Namun, keputusan untuk menggunakan desain berbasis DDD harus diambil setelah mempertimbangkan dengan hati-hati persyaratan model domain dan seberapa kompleks model bisnis yang mendasarinya akan direpresentasikan sebagai perangkat lunak.


