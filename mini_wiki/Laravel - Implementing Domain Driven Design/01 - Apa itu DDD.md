DDD sendiri dibangun menggunakan berbagai peraktik terbaik dan pola desain yang dapat diandalkan, dan memiliki akar yang berasal dari extreme programming (XP) dan pengembangan agile. Saya akan memperkenalkan kepada anda beberapa aspek fundamental yang lebih mendasar dari DDD, termasuk buruknya perangkat lunak dibuat tanpa best practicies dan pola SOLID karena ketidaktahuan pengembang atau upaya pengembang yang buruk.

Sederhananya DDD adalah serangkaian konsep, proses, dan teknik praktis dan berguna yang membantu dalam pemodelan sistem perangkat lunak kompleks secara sistematis dan terstruktur dengan fokus pada aspek inti dari aturan bisnis yang mendasarinya untuk menghasilkan model domain yang benar benar menjelaskan dan mewakili bisnis tersebut dalam hal perangkat lunak, dan kemudian membiarkan pengetahuan dan wawasan dari diskusi berulang dan pertemuan kelompok dengan para ahli domain yang bersangkutan memandu pengembangan dan pembangunan perangkat lunak yang pada akhirnya dibangun untuk melayani pelanggan atau pengguna depan bisnis tersebut. DDD pada dasarnya muncul dari kesenjangan industri perangkat lunak yang berkaitan dengan menjawab pertanyaan tentang bagaimana merancang dan mengembangkan perangkat lunak yang baik dan paling sesuai dengan bisnis tersebut. Tidak ada panduan ajaib yang memberikan standar atau pendekatan dasar apapun untuk membangun aplikasi yang berfokus pada domain aplikasi (domain centric), dan juga tidak ada pendekatan yang dipublikasikan untuk mempelajari seluk beluk dari proses inti bisnis yang cukup untuk membangun perangkat lunak yang mewakilinya.

Para progammer telah memiliki pola dalam kota alat kode kami selama bertahun tahun, meskipun mereka tidak pernah didokumentasikan seperti itu hingga tahun 1994 ketika gang of four menerbitkan buku desain pola yang sangat terkenal "Design Patterns: Element Of Reusable Object-Oriented Software". Design Patterns berfungsi sebagai seperangkat solusi praktis dan dapat diulang yang penting untuk masalah umum yang mungkin anda hadapi saat membangun program komputer. Mereka adalah cara yang terpikirkan dengan baik dan diuji dengan baik untuk mengatasi aspek aspek umum dari cakupan masalah yang mungkin anda temui dalam hampir semua program, dalam berbagai bahasa pemrorgamman. Salah satu pola tersebut, pola strategis terkenal, berguna ketika anda memberikan perilaku tambahan kepada objek pada saat runtime dengan mengemas perubahan ke dalam keluarga perilaku. Yang lain adalah pola adapter, yang digunakan untuk mengintegrasikan dua antarmuka yang berbeda (seperti yang berjalan pada sistem yang berbeda atau diprogram dalam bahasa pemrogramman yang benar benar berbeda). Jika anda memerlukan perilaku dinamis pada objek anda yang dapat ditambahkan atau dihapus saat runtime dan mengikuti suite yang mirip yang memungkinkan perhitungan agresi ditempatkan pada kelompok objek tersebut, anda bisa menggunakan decorator pattern.

Apa yang kita butuhkan adalah hal yang sama untuk mengembangkan solusi dalam bentuk kode untuk sejumlah masalah bisnis yang terus berkembang dan luas yang muncul sebagai tanggapan terhadap peningkatan permintaan pengembangan perangkat lunak. Dengan kata lain, kita membutuhkan suatu pendekatan untuk mengembangkan lapisan domain dari sebuah aplikasi sehingga kita dapat menyatakan model domain (bisnis) apa pun dalam bentuk perangkat lunak. Sifat masalah bisnis adalah cenderung sangat spesifik, dan solusi mereka merupakan hasil dari bertahun-tahun merancang, mengembangkan, menguji, dan menyempurnakan proses bisnis yang unik untuk setiap bisnis atau industri. Oleh karena itu, sulit untuk menetapkan standar atau praktik terbaik untuk memfasilitasi pengembangan aspek paling kritis dari proyek perangkat lunak mana pun: lapisan domain. Sebaliknya, ada banyak referensi, toolkit, dan kerangka kerja yang membantu merancang lapisan lain (yang mungkin memang berkomunikasi dan mengetahui tentang lapisan domain), tetapi mereka tidak mengkapsulkannya. Sebaliknya, mereka mengelilinginya. Lapisan infrastruktur pada dasarnya adalah perantara antara lapisan aplikasi dan model domain. Ini memfasilitasi semua bagian yang beroperasi, mengelola, dan mengelola objek domain secara langsung.

Apa yang kita butuhkan adalah taktik tentang bagaimana mencari sumber kebenaran di perusahaan tempat kita bekerja untuk memodelkannya dengan benar dalam perangkat lunak, dan alat untuk membantu kami mengimplementasikan model tersebut dengan cara yang berorientasi pada domain. Informasi bisnis tidak selalu langsung atau mudah untuk diperoleh, terutama dalam konteks proses bisnis yang kompleks yang tersebar di beberapa komponen (setidaknya kita berharap mereka terpisah dalam suatu struktur komponen, tetapi ini tidak selalu menjadi kenyataan). Dalam situasi di mana kode dalam aplikasi sangat "dicampur aduk" atau diubah oleh sejumlah pengembang selama bertahun-tahun sehingga perilakunya melenceng dari yang dimaksud atau dirancang, mengimplementasikan pendekatan yang berorientasi pada domain menjadi lebih sulit. Namun, masih mungkin untuk menghindari menulis ulang seluruh aplikasi (yang hampir selalu merupakan ide yang buruk). Kami akan menjelajahi cara melakukannya nanti dalam buku ini, tetapi jawaban singkatnya adalah dengan menggunakan lapisan anti-korupsi untuk memisahkan bagian-bagian aplikasi, kemudian terus menggantikan kode lama dengan bagian yang lebih kecil hingga lapisan tersebut menyerap kode lama, sehingga tidak ada kode lama yang tersisa sama sekali.
### Arsitektur
Arsitektur suatu sistem memperindah seluruh struktur model domain sistem, termasuk objek domain, modul, konteks terbatas, dan berbagai interaksi di antara mereka. Arsitektur merupakan salah satu hal paling penting dalam suatu aplikasi, karena merupakan dasar utama dalam perangkat lunak dan bertindak sebagai "tiang dukungan" bagi bagian lain dari aplikasi untuk dibangun.

Apa yang sering terjadi dalam dunia nyata adalah bahwa proses bisnis dan model-model ini dibangun tanpa praktik terbaik atau struktur yang tepat dan digunakan dalam produksi karena "berfungsi". Jangan salah paham, para pengembang bekerja dengan apa yang ada dan biasanya dapat "merangkai" sesuatu yang memang "berfungsi". Namun, ketika kita mengabaikan untuk melakukan refaktor terhadap kode ini setelah melakukan penyempurnaan pada proses itu sendiri, atau gagal menyempurnakan definisi yang tidak jelas atau samar yang mungkin telah kita klarifikasi, atau gagal mencerminkan wawasan yang diperoleh ke dalam model bisnis dan bagaimana wawasan tersebut memengaruhi operasi bisnis dan perangkat lunaknya, kita kemungkinan besar menuju ke arah "big ball of mud" (atau yang saya sebut sebagai "big ball of sh...potato pottÃ¥to").

Dalam konteks ini, "big ball of mud" merujuk pada kondisi di mana kode menjadi sulit dimengerti, sulit dipelihara, dan tidak mengikuti praktik-praktik terbaik atau struktur yang baik. Pernyataan tersebut menyoroti pentingnya melakukan pemeliharaan, refaktorisasi, dan pembaruan terhadap arsitektur perangkat lunak agar tetap relevan dan efisien seiring waktu.

> "sebuah sistem yang dibangun secara sembarangan, merambat, berantakan, seperti hutan kawat duct tape, dan benang rafia kode spageti. Sistem-sistem ini menunjukkan tanda-tanda pertumbuhan yang tidak teratur, dan perbaikan berulang yang bersifat ekspedisi..." â€” Brian Foote

Lebih sering daripada tidak, bola lumpur ini dibangun sebagai arsitektur monolitik, yang kurang memiliki pemisahan konsep yang lengkap pada "tingkat platform" (tingkat fisik). Arsitektur monolitik bersifat mandiri dan mencakup dalam dirinya semua aspek aplikasi (infrastruktur, basis data, tingkat aplikasi, dan masalah presentasi). Kita akan membahas lapisan arsitektur dari sistem perangkat lunak lebih lanjut dalam bab ini.
Kebalikan dari aplikasi monolitik adalah mikroservis. Mikroservis adalah aplikasi kecil yang terdistribusi di berbagai komponen yang bersama-sama membentuk sistem lengkap yang dapat digunakan. Pengaturan yang terlibat dalam arsitektur mikroservis jauh lebih dramatis daripada hanya menggunakan nama direktori (yang sebenarnya hanya memisahkan struktur-struktur berbagai kelompok yang terkait secara fisik). Komponen-komponen itu sendiri seringkali ada di platform terpisah, biasanya di mesin-mesin terpisah di cloud, dan menerapkan berbagai strategi untuk memfasilitasi penggunaannya dan memungkinkan komunikasi di antara mereka dan klien (kode yang memanggil).

Dalam konteks ini, "monolitik" mengacu pada aplikasi yang dibangun sebagai satu entitas besar yang mencakup semua aspek dari infrastruktur hingga tampilan pengguna, tanpa pemisahan yang jelas antara bagian-bagian tersebut. Sebaliknya, "mikroservis" mengacu pada pendekatan di mana aplikasi dibangun sebagai serangkaian layanan kecil dan terpisah yang bekerja bersama untuk membentuk keseluruhan sistem. Mikroservis umumnya memiliki keuntungan dalam hal skalabilitas, pemeliharaan, dan fleksibilitas, tetapi juga memerlukan pengaturan yang lebih kompleks.
### Enter Laravel